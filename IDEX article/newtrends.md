# New trends in decentralized exchange applications; exploring the design space

### This article aims to raise awareness among the blockchain ecosystem about the ways in which decentralized exchange (DEX) can significantly evolve during the next year or so. We concentrate in presenting new design ideas for applications. With the intent of being as concrete as possible we introduce a demo smart contract called "Dealer" which contains several convenient features that might be considered in subsequent community discussions. We illustrate each of these features with examples. Finally we discuss possible [SUAVE](https://writings.flashbots.net/mevm-suave-centauri-and-beyond) applications that may play an important role in the path that connects user's action with on-chain execution.

## Introduction

Up to this day, decentralized exchange (DEX) in Ethereum is dominated by automated market makers (AMMs). Since their introduction, they have proven to be a powerful tool for both liquidity providers and traders. As a consequence of their wide adoption we saw the rise of MEV, which is by now a well-known phenomenon. During last years, Flashbots has provided many interesting products for both preventing MEV and democratizing access to MEV. Other teams have focused on developing DEX applications based on smart contracts which naturally offer MEV protection to users. Some of these are [CoWswap](https://cow.fi/), [Fusion](https://1inch.io/es/fusion/) and [UniswapX](https://blog.uniswap.org/uniswapx-protocol). To operate these apps, end users have to sign orders that are not transactions. At a later step, these orders get executed at the smart contract when included in a transaction sent by another actor, called "solver" or "filler". The distinctive feature recently introduced by UniswapX has been to turn into permissionless the role of the filler. Arguably, this type of systems deserve a name. We may call them "Integral DEX applications" (IDEX). The name comes from the fact that they are able to aggregate arbitrary users' orders jointly with AMMs swaps or any other sources of liquidity. We would like to boost the development of the IDEX family, since we understand that there is a lot to gain from possible improvements and adoption. In the following sections, we want to illustrate many things that can be done.

## Dealer smart contract

As a means to expose several significant use cases in the most concrete way, we present an IDEX smart contract called "Dealer" with its corresponding test cases. This smart contract has not been audited. It currently only serves the purposes of research and dissemination of ideas. 

The main guiding principles of this smart contract are flexibility and efficiency. Here, flexibility means that it should support a very general class of trading operations.
As we will see, in many cases IDEX smart contracts are expected to work in combination with other systems running off-chain or in a side chain. Thus, flexibility is related to adoption. Efficiency means to optimize gas costs. The operative cost will determine the minimum viable trade size and therefore influence the ecosystem scalability. We understand that a gas saving as low as 10K per trade may be significant. 

We first present the smart contract design and then highlight some expected use cases. We chose this logical order of exposition, though it is also reasonable to read the use cases first.

An "order" is a user generated piece of data to be executed by the contract's main function. 

#### *Order* structure

*allowedTokens*: a list of ERC20 tokens that the user allows the contract to transfer from the user when executing the order. Previously, the user had to make the corresponding ERC20 approve.

*inequalities*: this is a finite set of linear inequalities that the balances of the user's tokens has to satisfy. The variables are token balances at both the beginning and the end of the order execution. This allows the user to impose conditions on the prices and amounts of trades.

*conditions*: this field allows the user to express any other custom conditions. A condition takes the form of any contract function, since they can perform arbitrary verifications and revert whenever the condition is not met.

*expirationBlock*: the block number at which the order expires.

### Main function flow

The main function is called *fillOrders*. The *filler* is the agent calling this function. The input consists of a set of orders generated by users but chosen by the filler, their signatures, a set of transfers from users, a set of transfers from the filler (both specified by the filler) and a set of other transactions to be called after the transfers, which may include transfers back to the users.

The flow of "fillOrders" can be summarized as follows.

(1) Verify signatures and retrieve users' addresses.

(2) Record balances before execution.

(3) Execute transfers from users and transfers from the filler.

(4) Call smart contract functions specified by the filler. These are any external or internal functions, with the exception of those whose names are "transferFrom" and "burnFrom".

(5) Check balances inequalities, expiration time and other arbitrary conditions as specified by the orders.

The direct style of the smart contract makes it easy to read. Each of these steps is indicated with a comment in the code. Let us highlight some salient features emerging from this design.

(a) The orders do not specify transfer amounts nor recipients. This flexibility property allows partial execution and arbitrary routing of funds.

(b) The same order might be executed multiple times until the expiration time.
To save gas, the contract does not store any data about the orders.

(c) Linear inequalities on user's balances also allow to specify minimum execution amount. Thus an order can forbid partial fills for itself.

(d) Other contracts functions can be called directly from this smart contract by the filler. This may include AMMs swaps and transfers to the users or the filler.


## Notable use cases

### (1) Minimal case: maker-taker trade

User 1 wants to swap 5000 units of token A by 10000 units of token B. More precisely,
user 1 signs an order to swap token A to token B at a rate at least 1:2, to obtain at most 10000 units of token B. A second user likes this price and takes the order. The second user is therefore the filler. The Dealer contract performs two transfers. This operation only consumes 105K of gas (using OpenZeppelin implementation of ERC20). The users benefit from the absense of any intermediaries other than the blockchain. If there were AMMs operating the pair A/B, whose spot price was 1:2, then none of the users could have obtained a better deal by swapping at the AMM. 

### (1') Partial fill

In many cases the filler user may want to take only a portion of the order. In this way, the full order can be processed by different fillers after some time.

### (2) Walrasian auction

Here we assume that A/B is a very liquid pair. Consider the following plausible scenario. There is an AMM of the *constant product* type available, operating A/B with a 0.3% pool fee. There is a public entity that receives orders privately and generates fair market executions. Assume that at some point in time, there are 10M units of token A and 20M units of token B at the AMM. The filler entity has received five orders:

(a) Sell 80K token A at a price at least 1.99.

(b) Sell 5K token A at a price at least 1.985.

(c) Sell 1K token A at a price at least 1.984.

(d) Buy 55K token A at a price at most 2.

(e) Buy 21K token A at a price at most 1.993.

In this situation, considering the orders and the AMM, the filler entity's task is to find an equilibrium price and a fair execution. To each order, it will charge the gas cost, assumed to be 2 units of B (in current tests this cost is twice the cost of an ERC20 transfer), and then apply a small fee of 0.05%. To obtain a convenient AMM swap, it considers a gas cost of 3 units of B and also applies a 0.05% fee (i.e. the filler interprets AMM swaps in this way to solve the system). With these premises, the filler finds the equilibrium price 1.9908 and the following execution:

<pre>
(a) 80,000  ---> 159,182
(b) 5,000   ---> 9,947
(c) 1,000   ---> 1,987
(d) 55,500  <--- 110,542
(e) 21,000  <--- 41,825
(AMM) 9,500 <--- 18,925 (the AMM receives 9,500 of A and gives back 18,925 B).
(F) The filler keeps a surplus of 176 units of token B.
</pre>

Arrows from left to right multiply by 1.9898 and substract 2 units. Arrows from right to left substract 2 units (except the AMM case, 3 units) and then divide by 1.9918.

The total gas cost for this transaction is 456K. For this test we used OpenZeppelin ERC20 and a Uniswap V2 pool.

Notice that users receive an execution that is better than their signed limit price.
On the other hand, orders sent to public mempools will probably get executed at the worst possible price. Thus, the advantage of such "walrasian auction solver" for the users is that, by signing a suboptimal price, they get both a good probability of execution and a fair price.

### (3) Temporary AMMs

Any user can build a simple AMM by signing a pair of orders. Imagine a user that starts with 600K units of token B. The user signs:

(a) buy any amount of token A at a price at most 1.98 B/A.

(b) sell any amount of token A at a price at least 2 B/A.

If the price starts at 1.99, then goes below 1.98 and then it goes above 2, the user will make a profit of 6062 units of token B. The same orders can be executed again and again until the expiration time.

By pointing the order's condition to other functions, it is possible to set up AMMs defined by arbitrary curves. This could be practical for temporary liquidity providers, since in this way they avoid the cost of joining and exiting pools.

### (4) Many tokens clearing

A batch of orders operating more than two tokens can be cleared at the same transaction. To our knowledge this is not possible to do in traditional exchanges. The simplest case would be a triangle:

user1 ---1000A---> user2

user2 ---2000B---> user3

user3 ---3000C---> user1

user3 -----30C---> filler

where each user signed one order involving only one pair.